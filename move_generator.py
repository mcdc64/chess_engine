from board_elements import Board, Color, Piece, PieceType,Move
import copy
# moves generated by this file have a start square, an end square, and a PieceType in case the move is a promotion
def get_bishop_moves(board,i,j): #get moves of a bishop on board at position i,j

    out_moves = []


    for d in range(1,8): # upper right diagonal
        if((i+d<8) and (j+d<8)):
            if(board.pieces[i+d][j+d].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i,j],[i+d,j+d],PieceType.EMPTY))
            else:
                if(board.pieces[i+d][j+d].color != board.color_to_move):
                    out_moves.append(Move([i,j],[i+d,j+d],PieceType.EMPTY))
                break
        else:
            break

    for d in range(1,8): # upper left diagonal
        if((i-d>=0) and (j+d<8)):
            if(board.pieces[i-d][j+d].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i,j],[i-d,j+d],PieceType.EMPTY))
            else:
                if(board.pieces[i-d][j+d].color != board.color_to_move):
                    out_moves.append(Move([i,j],[i-d,j+d],PieceType.EMPTY))
                break
        else:
            break

    for d in range(1,8): # lower left diagonal
        if((i-d>=0) and (j-d>=0)):
            if(board.pieces[i-d][j-d].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i,j],[i-d,j-d],PieceType.EMPTY))
            else:
                if(board.pieces[i-d][j-d].color != board.color_to_move):
                    out_moves.append(Move([i,j],[i-d,j-d],PieceType.EMPTY))
                break
        else:
            break

    for d in range(1,8): # lower right diagonal
        if((i+d<8) and (j-d>=0)):
            if(board.pieces[i+d][j-d].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i,j],[i+d,j-d],PieceType.EMPTY))
            else:
                if(board.pieces[i+d][j-d].color != board.color_to_move):
                    out_moves.append(Move([i,j],[i+d,j-d],PieceType.EMPTY))
                break
        else:
            break
    return out_moves

def get_rook_moves(board,i,j):
    out_moves = []

    for d in range(1, 8):  # right rank
        if (i + d < 8):
            if (board.pieces[i + d][j].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i, j], [i + d, j],PieceType.EMPTY))
            else:
                if (board.pieces[i + d][j].color != board.color_to_move):
                    out_moves.append(Move([i, j], [i + d, j],PieceType.EMPTY))
                break
        else:
            break

    for d in range(1, 8):  # left rank
        if (i - d >= 0):
            if (board.pieces[i - d][j].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i, j], [i - d, j],PieceType.EMPTY))
            else:
                if (board.pieces[i - d][j].color != board.color_to_move):
                    out_moves.append(Move([i, j], [i - d, j],PieceType.EMPTY))
                break
        else:
            break

    for d in range(1, 8):  # upper file
        if (j + d < 8):
            if (board.pieces[i][j + d].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i, j], [i, j + d],PieceType.EMPTY))
            else:
                if (board.pieces[i][j + d].color != board.color_to_move):
                    out_moves.append(Move([i, j], [i, j + d],PieceType.EMPTY))
                break
        else:
            break

    for d in range(1, 8):  # lower file
        if (j - d >= 0):
            if (board.pieces[i][j - d].piece_type == PieceType.EMPTY):
                out_moves.append(Move([i, j], [i, j - d],PieceType.EMPTY))
            else:
                if (board.pieces[i][j - d].color != board.color_to_move):
                    out_moves.append(Move([i, j], [i, j - d],PieceType.EMPTY))
                break
        else:
            break
    return out_moves

def get_knight_moves(board,i,j):
    eight_squares = [[i+2,j+1],[i+2,j-1],[i+1,j-2],[i-1,j-2],[i-2,j-1],[i-2,j+1],[i-1,j+2],[i+1,j+2]]

    out_moves = []
    for square in eight_squares:
        square_x = square[0]
        square_y = square[1]
        if(0<=square_x<8 and 0<=square_y<8): #making sure the squares are on the board
            if(board.pieces[square_x][square_y].color != board.color_to_move): #making sure another piece of the same color doesn't occupy the squares

                out_moves.append(Move([i,j],[square_x,square_y],PieceType.EMPTY))
    return out_moves

def get_pawn_moves(board,i,j):
    out_moves = []
    if(board.color_to_move==Color.WHITE):
        left_diagonal_move = Move([i,j],[i-1,j+1],PieceType.EMPTY)
        right_diagonal_move = Move([i,j],[i+1,j+1],PieceType.EMPTY)
        forward_move = Move([i,j],[i,j+1],PieceType.EMPTY)
        two_forward_move = Move([i,j],[i,j+2],PieceType.EMPTY)
        if(j==1 and board.pieces[i][2].piece_type == PieceType.EMPTY and board.pieces[i][3].piece_type == PieceType.EMPTY):
            out_moves.append(two_forward_move)
        # pawn can move diagonally if an opposite-colour piece is there or if en passant is available on that square
        if(j+1 != 7): # if the move is not a promotion...
            if(i-1>=0 and j+1<8 and (board.pieces[i-1][j+1].color == Color.BLACK or board.en_passant == [i-1,j+1])):
                out_moves.append(left_diagonal_move)
            if(i+1<8 and j+1<8 and (board.pieces[i+1][j+1].color == Color.BLACK or board.en_passant == [i+1,j+1])):
                out_moves.append(right_diagonal_move)

            if(j+1<8 and board.pieces[i][j+1].piece_type == PieceType.EMPTY):
                out_moves.append(forward_move)
        else: # we need four different moves for each of forward, left diagonal, right diagonal - one for each promotion
            promotion_pieces = [PieceType.QUEEN,PieceType.ROOK,PieceType.BISHOP,PieceType.KNIGHT]
            for piece in promotion_pieces:
                if (i - 1 >= 0 and j + 1 < 8 and (board.pieces[i - 1][j + 1].color == Color.BLACK or board.en_passant == [i - 1, j + 1])):
                    left_diagonal_move = Move([i, j], [i - 1, j + 1], piece)
                    out_moves.append(left_diagonal_move)

                if (i + 1 < 8 and j + 1 < 8 and (board.pieces[i + 1][j + 1].color == Color.BLACK or board.en_passant == [i + 1, j + 1])):
                    right_diagonal_move = Move([i, j], [i + 1, j + 1], piece)
                    out_moves.append(right_diagonal_move)

                if (j + 1 < 8 and board.pieces[i][j + 1].piece_type == PieceType.EMPTY):
                    forward_move = Move([i, j], [i, j + 1], piece)
                    out_moves.append(forward_move)

    if(board.color_to_move==Color.BLACK):
        left_diagonal_move = Move([i,j],[i-1,j-1],PieceType.EMPTY)
        right_diagonal_move = Move([i,j],[i+1,j-1],PieceType.EMPTY)
        forward_move = Move([i,j],[i,j-1],PieceType.EMPTY)
        two_forward_move = Move([i,j],[i,j-2],PieceType.EMPTY)
        # pawn can move diagonally if an opposite-colour piece is there or if en passant is available on that square
        if (j == 6 and board.pieces[i][5].piece_type == PieceType.EMPTY and board.pieces[i][4].piece_type == PieceType.EMPTY):
            out_moves.append(two_forward_move)

        if(j-1 != 0):
            if(i-1>=0 and j-1>=0 and (board.pieces[i-1][j-1].color == Color.WHITE or board.en_passant == [i-1,j-1])):
                out_moves.append(left_diagonal_move)
            if(i+1<8 and j-1>=0 and (board.pieces[i+1][j-1].color == Color.WHITE or board.en_passant == [i+1,j-1])):
                out_moves.append(right_diagonal_move)
            if(j-1>=0 and board.pieces[i][j-1].piece_type == PieceType.EMPTY):
                out_moves.append(forward_move)
        else:
            promotion_pieces = [PieceType.QUEEN,PieceType.ROOK,PieceType.BISHOP,PieceType.KNIGHT]
            for piece in promotion_pieces:
                if (i - 1 >= 0 and j - 1 >= 0 and (board.pieces[i - 1][j - 1].color == Color.WHITE or board.en_passant == [i - 1, j - 1])):
                    left_diagonal_move = Move([i,j],[i-1,j-1],piece)
                    out_moves.append(left_diagonal_move)
                if (i + 1 < 8 and j - 1 >= 0 and (board.pieces[i + 1][j - 1].color == Color.WHITE or board.en_passant == [i + 1, j - 1])):
                    right_diagonal_move = Move([i, j], [i + 1, j - 1], piece)
                    out_moves.append(right_diagonal_move)
                if (j - 1 >= 0 and board.pieces[i][j - 1].piece_type == PieceType.EMPTY):
                    forward_move = Move([i, j], [i, j - 1], piece)
                    out_moves.append(forward_move)

    return out_moves

def get_king_moves(board,i,j,allow_castling = True):
    eight_squares = [[i+1,j],[i+1,j-1],[i,j-1],[i-1,j-1],[i-1,j],[i-1,j+1],[i,j+1],[i+1,j+1]]
    out_moves = []
    for square in eight_squares:
        if(0<=square[0]<8 and 0<=square[1]<8):
            target_piece = board.pieces[square[0]][square[1]]
            if(target_piece.color != board.color_to_move or target_piece.piece_type == PieceType.EMPTY):
                out_moves.append(Move([i,j],[square[0],square[1]],PieceType.EMPTY))
    if(board.color_to_move==Color.WHITE and allow_castling):
        if(not in_check(board)):
            if(board.castling_rights[0] and board.pieces[5][0].piece_type == PieceType.EMPTY and board.pieces[6][0].piece_type == PieceType.EMPTY):
                if (not(is_attacked(board,5,0)) and not is_attacked(board,6,0)):
                    out_moves.append(Move([i,j],[6,0],PieceType.EMPTY))

            if (board.castling_rights[1] and board.pieces[3][0].piece_type == PieceType.EMPTY and
                    board.pieces[2][0].piece_type == PieceType.EMPTY and
                    board.pieces[1][0].piece_type == PieceType.EMPTY):
                if (not (is_attacked(board, 3, 0)) and not is_attacked(board, 2, 0) and not is_attacked(board,1,0)):

                    out_moves.append(Move([i, j], [2, 0],PieceType.EMPTY))

    if (board.color_to_move == Color.BLACK and allow_castling):
        if not in_check(board):
            if (board.castling_rights[2] and board.pieces[5][7].piece_type == PieceType.EMPTY and
                    board.pieces[6][7].piece_type == PieceType.EMPTY):
                if (not (is_attacked(board, 5, 7)) and not is_attacked(board, 6, 7)):
                    out_moves.append(Move([i, j], [6, 7],PieceType.EMPTY))

            if (board.castling_rights[3] and board.pieces[3][7].piece_type == PieceType.EMPTY and
                    board.pieces[2][7].piece_type == PieceType.EMPTY and
                    board.pieces[1][7].piece_type == PieceType.EMPTY):
                if (not (is_attacked(board, 3, 7)) and not is_attacked(board, 2, 7) and not is_attacked(board, 1, 7)):
                    out_moves.append(Move([i, j], [2, 7],PieceType.EMPTY))

    return out_moves

def get_queen_moves(board,i,j):
    # use a lazy shortcut to get the queen moves
    bishop_moves = get_bishop_moves(board,i,j)
    rook_moves = get_rook_moves(board,i,j)
    out_moves = bishop_moves+rook_moves
    return out_moves

def generate_pseudo_moves(board):
    moving_color = board.color_to_move
    # get all pieces of the moving color
    moving_piece_positions = []
    if(moving_color == Color.WHITE):
        moving_piece_positions = board.white_piece_positions
    if(moving_color == Color.BLACK):
        moving_piece_positions = board.black_piece_positions
    pseudo_legal_moves = []


    for position in moving_piece_positions:
        i = position[0]
        j = position[1]
        curr_piece = board.pieces[i][j]
        if(curr_piece.piece_type == PieceType.BISHOP):
            pseudo_legal_moves += get_bishop_moves(board,i,j)
        elif (curr_piece.piece_type == PieceType.ROOK):
            pseudo_legal_moves += get_rook_moves(board, i, j)
        elif (curr_piece.piece_type == PieceType.QUEEN):
            pseudo_legal_moves += get_queen_moves(board, i, j)
        elif (curr_piece.piece_type == PieceType.KNIGHT):
            pseudo_legal_moves += get_knight_moves(board, i, j)
        elif (curr_piece.piece_type == PieceType.PAWN):
            pseudo_legal_moves += get_pawn_moves(board, i, j)
        elif (curr_piece.piece_type == PieceType.KING):
            pseudo_legal_moves += get_king_moves(board, i, j)
    return pseudo_legal_moves

def one_pseudo_moves(board,i,j): #get the pseudo moves of just the piece at i,j (mainly used for highlighting the board)
    curr_piece = board.pieces[i][j]

    pseudo_legal_moves = []
    if (curr_piece.piece_type == PieceType.BISHOP):
        pseudo_legal_moves += get_bishop_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.ROOK):
        pseudo_legal_moves += get_rook_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.QUEEN):
        pseudo_legal_moves += get_queen_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.KNIGHT):
        pseudo_legal_moves += get_knight_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.PAWN):
        pseudo_legal_moves += get_pawn_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.KING):
        pseudo_legal_moves += get_king_moves(board, i, j)
    return pseudo_legal_moves

def one_legal_moves(board,i,j):
    curr_piece = board.pieces[i][j]

    pseudo_legal_moves = []
    if (curr_piece.piece_type == PieceType.BISHOP):
        pseudo_legal_moves += get_bishop_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.ROOK):
        pseudo_legal_moves += get_rook_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.QUEEN):
        pseudo_legal_moves += get_queen_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.KNIGHT):
        pseudo_legal_moves += get_knight_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.PAWN):
        pseudo_legal_moves += get_pawn_moves(board, i, j)
    elif (curr_piece.piece_type == PieceType.KING):
        pseudo_legal_moves += get_king_moves(board, i, j)
    allowed_moves = []
    for move in pseudo_legal_moves:
        moved_board = board.hypo_move(move)
        moved_board.toggle_color()
        if (not in_check(moved_board)):
            allowed_moves.append(move)
    return allowed_moves

def generate_legal_moves(board):
    pseudo_moves = generate_pseudo_moves(board)
    allowed_moves = []
    for move in pseudo_moves:

        board.make_move(move)
        board.toggle_color()
        if (not in_check(board)):
            allowed_moves.append(move)
        board.toggle_color()
        board.unmake_move(move)
    return allowed_moves

def in_check(board): # returns True if the color to move is currently in check, False otherwise
    # find the king
    king_pos = []
    opposite_color = Color.BLACK
    if(board.color_to_move == Color.WHITE):
        for position in board.white_piece_positions:
            if board.pieces[position[0]][position[1]].piece_type == PieceType.KING:
                king_pos = position
    if(board.color_to_move == Color.BLACK):
        opposite_color = Color.WHITE
        for position in board.black_piece_positions:
            if board.pieces[position[0]][position[1]].piece_type == PieceType.KING:
                king_pos = position
    i = king_pos[0]
    j = king_pos[1]

    if(is_attacked(board,i,j)):
        return True
    return False

def is_attacked(board,i,j): # returns True if square (i,j) is attacked by the opposite colour, false otherwise
    opposite_color = Color.BLACK
    if(board.color_to_move == Color.BLACK):
        opposite_color = Color.WHITE
    bishop_attack_moves = get_bishop_moves(board,i,j)
    rook_attack_moves = get_rook_moves(board,i,j)
    # no need to generate the queen moves; can just check if the bishop or rook squares have a queen
    knight_attack_moves = get_knight_moves(board,i,j)
    king_attack_moves = get_king_moves(board,i,j,False)
    pawn_attack_moves = []
    if(board.color_to_move == Color.WHITE and j<7):
        if(i<7):
            pawn_attack_moves.append(Move([i,j],[i+1,j+1],PieceType.EMPTY))
        if(i>0):
            pawn_attack_moves.append(Move([i, j], [i - 1, j + 1], PieceType.EMPTY))
    if(board.color_to_move == Color.BLACK and j>0):
        if (i < 7):
            pawn_attack_moves.append(Move([i, j], [i + 1, j - 1], PieceType.EMPTY))
        if (i > 0):
            pawn_attack_moves.append(Move([i, j], [i - 1, j - 1], PieceType.EMPTY))
    attacker_positions = board.white_piece_positions
    if(opposite_color == Color.BLACK):
        attacker_positions = board.black_piece_positions

    for attack_move in bishop_attack_moves:
        attacker_pos = attack_move.new_position
        attacker = board.pieces[attacker_pos[0]][attacker_pos[1]]
        if((attacker.piece_type==PieceType.BISHOP or attacker.piece_type == PieceType.QUEEN) and attacker.color==opposite_color):
            return True
    for attack_move in rook_attack_moves:
        attacker_pos = attack_move.new_position
        attacker = board.pieces[attacker_pos[0]][attacker_pos[1]]
        if((attacker.piece_type==PieceType.ROOK or attacker.piece_type == PieceType.QUEEN) and attacker.color==opposite_color):
            return True
    for attack_move in knight_attack_moves:
        attacker_pos = attack_move.new_position
        attacker = board.pieces[attacker_pos[0]][attacker_pos[1]]
        if(attacker.piece_type==PieceType.KNIGHT and attacker.color==opposite_color):
            return True
    for attack_move in pawn_attack_moves:
        attacker_pos = attack_move.new_position
        attacker = board.pieces[attacker_pos[0]][attacker_pos[1]]
        if(attacker.piece_type==PieceType.PAWN and attacker.color==opposite_color):
            return True
    for attack_move in king_attack_moves:
        attacker_pos = attack_move.new_position
        attacker = board.pieces[attacker_pos[0]][attacker_pos[1]]
        if(attacker.piece_type==PieceType.KING and attacker.color==opposite_color):
            return True
    '''
    for position in attacker_positions:
        attack_piece = board.pieces[position[0]][position[1]]
        attack_move = Move([i, j], position, PieceType.EMPTY)
        if(attack_piece.piece_type == PieceType.BISHOP or attack_piece.piece_type == PieceType.QUEEN):
            if(attack_move in bishop_attack_moves):
                return True
        if(attack_piece.piece_type == PieceType.ROOK or attack_piece.piece_type == PieceType.QUEEN):
            if(attack_move in rook_attack_moves):
                return True
        if(attack_piece.piece_type == PieceType.KNIGHT):
            if(attack_move in knight_attack_moves):
                return True
        if(attack_piece.piece_type == PieceType.KING):
            if(attack_move in king_attack_moves):
                return True
        if(attack_piece.piece_type == PieceType.PAWN):
            if(attack_move in pawn_attack_moves):
                return True
    '''
    return False

def get_attacking_pieces(board,i,j): # returns all positions of opposite color pieces that attack (i,j)
    attacking_pieces = []
    opposite_color = Color.BLACK
    if(board.color_to_move == Color.BLACK):
        opposite_color = Color.WHITE
    bishop_attack_moves = get_bishop_moves(board,i,j)
    rook_attack_moves = get_rook_moves(board,i,j)
    # no need to generate the queen moves; can just check if the bishop or rook squares have a queen
    knight_attack_moves = get_knight_moves(board,i,j)
    king_attack_moves = get_king_moves(board,i,j,False)
    pawn_attack_moves = []
    if(board.color_to_move == Color.WHITE and j<7):
        if(i<7):
            pawn_attack_moves.append(Move([i,j],[i+1,j+1],PieceType.EMPTY))
        if(i>0):
            pawn_attack_moves.append(Move([i, j], [i - 1, j + 1], PieceType.EMPTY))
    if(board.color_to_move == Color.BLACK and j>0):
        if (i < 7):
            pawn_attack_moves.append(Move([i, j], [i + 1, j - 1], PieceType.EMPTY))
        if (i > 0):
            pawn_attack_moves.append(Move([i, j], [i - 1, j - 1], PieceType.EMPTY))

    for move in bishop_attack_moves:
        attacker_square = move.new_position
        attacker_x,attacker_y = attacker_square[0],attacker_square[1]
        attack_piece = board.pieces[attacker_x][attacker_y]
        if((attack_piece.piece_type == PieceType.BISHOP or attack_piece.piece_type == PieceType.QUEEN) and attack_piece.color == opposite_color):
            attacking_pieces.append([attacker_x,attacker_y])
    for move in rook_attack_moves:
        attacker_square = move.new_position
        attacker_x,attacker_y = attacker_square[0],attacker_square[1]
        attack_piece = board.pieces[attacker_x][attacker_y]
        if((attack_piece.piece_type == PieceType.ROOK or attack_piece.piece_type == PieceType.QUEEN) and attack_piece.color == opposite_color):
            attacking_pieces.append([attacker_x,attacker_y])
    for move in knight_attack_moves:
        attacker_square = move.new_position
        attacker_x,attacker_y = attacker_square[0],attacker_square[1]
        attack_piece = board.pieces[attacker_x][attacker_y]
        if((attack_piece.piece_type == PieceType.KNIGHT) and attack_piece.color == opposite_color):
            attacking_pieces.append([attacker_x,attacker_y])
    for move in pawn_attack_moves:
        attacker_square = move.new_position
        attacker_x,attacker_y = attacker_square[0],attacker_square[1]
        attack_piece = board.pieces[attacker_x][attacker_y]
        if((attack_piece.piece_type == PieceType.PAWN) and attack_piece.color == opposite_color):
            attacking_pieces.append([attacker_x,attacker_y])
    for move in king_attack_moves:
        attacker_square = move.new_position
        attacker_x,attacker_y = attacker_square[0],attacker_square[1]
        attack_piece = board.pieces[attacker_x][attacker_y]
        if((attack_piece.piece_type == PieceType.KING) and attack_piece.color == opposite_color):
            attacking_pieces.append([attacker_x,attacker_y])
    return attacking_pieces

def castle_str(board,old_position,new_position):

    old_x,old_y = old_position
    new_x,new_y = new_position
    moving_piece = board.pieces[old_x][old_y]
    new_piece = board.pieces[new_x][new_y]
    if (moving_piece.piece_type == PieceType.KING and old_position == [4, 0] and (new_position == [6, 0] or new_position == [7, 0])):
        return "O-O"
    elif (moving_piece.piece_type == PieceType.KING and old_position == [4, 0] and (new_position == [0, 0] or new_position == [1, 0] or new_position == [2,0])):
        return "O-O-O"
    if (moving_piece.piece_type == PieceType.KING and old_position == [4, 7] and (new_position == [6, 7] or new_position == [7, 7])):
        return "O-O"
    elif (moving_piece.piece_type == PieceType.KING and old_position == [4, 7] and (new_position == [0, 7] or new_position == [1, 7] or new_position == [2,7])):
        return "O-O-O"
    return "No Move"

def move_string(board,move):
    # return the string corresponding to a given (hypothetical) move; does NOT execute the move
    # now deals with ambiguities (specifies file or rank or both as needed if two pieces of the same type attack a square)
    old_position = move.old_position
    new_position = move.new_position
    en_passant = move.is_en_passant
    promote_choice = move.promote_piece
    castling = castle_str(board,old_position,new_position)
    if(castling !="No Move"):
        return castling
    move_str = ""
    old_piece = board.pieces[old_position[0]][old_position[1]]
    nums = [0,1,2,3,4,5,6]
    strs = ["","","N","B","R","Q","K"]
    letters = "abcdefgh"
    move_str+= strs[old_piece.piece_type.value]

    # get all pieces attacking the new square (in case of ambiguity)
    opposite_board = copy.deepcopy(board)
    opposite_board.toggle_color()
    attacker_positions = get_attacking_pieces(opposite_board,new_position[0],new_position[1])
    like_attackers = []
    for position in attacker_positions:

        if board.pieces[position[0]][position[1]].piece_type == old_piece.piece_type and position != old_position:
            like_attackers.append([position[0],position[1]])
    if(len(like_attackers)>0 and old_piece.piece_type != PieceType.PAWN):
        rank_enough = True
        file_enough = True
        for attacker in like_attackers:
            if(attacker[0] == old_position[0]):
                rank_enough = False
            if(attacker[1] == old_position[1]):
                file_enough = False
        if(rank_enough):
            move_str+= letters[old_position[0]]
        elif(file_enough):
            move_str += str(old_position[1]+1)
        else:
            move_str += letters[old_position[0]]
            move_str += str(old_position[1]+1)

    new_piece = board.pieces[new_position[0]][new_position[1]]
    if(new_piece.piece_type!=PieceType.EMPTY or en_passant):
        if (old_piece.piece_type == PieceType.PAWN):
            move_str += letters[old_position[0]]
        move_str+="x"
    letters = "abcdefgh"
    move_str+=(letters[new_position[0]])

    move_str+=(str(new_position[1]+1))
    if(promote_choice != PieceType.EMPTY):
        if(promote_choice ==PieceType.QUEEN):
            move_str += "=Q"
        if(promote_choice ==PieceType.ROOK):
            move_str += "=R"
        if(promote_choice ==PieceType.BISHOP):
            move_str += "=B"
        if(promote_choice ==PieceType.KNIGHT):
            move_str += "=N"
    next_board = board.hypo_move(move)
    #next_board.toggle_color()
    allowed_moves = generate_legal_moves(next_board)
    if(in_check(next_board) and len(allowed_moves)>0):
        move_str += "+"
    if(len(allowed_moves)==0):
        move_str += "#"
    return move_str

